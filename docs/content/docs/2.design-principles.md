---
title: Design Principles
description: Core design decisions behind nuxt-auth-ui
navigation.order: 3
---

Understanding the design philosophy behind our auth UI will help you use them effectively and extend them when needed.

## Component Architecture

### Conditional Rendering

Components that typically aren't tied to auth-specific _routes_ render based on authentication state:

```vue
<template>
  <!-- Only renders when unauthenticated -->
  <ASignInButton />

  <!-- Only renders when authenticated -->
  <AUserMenu />
</template>
```

**Why?** Clean, predictable behavior. No need for manual state management.

## Configuration Philosophy

### Override-Friendly Props

Components accept standard Nuxt UI props that can be overridden:

```vue
<!-- Default with icon -->
<ASignInButton />

<!-- Custom icon -->
<ASignInButton leading-icon="i-heroicons-user" />

<!-- No icon -->
<ASignInButton :leading-icon="undefined" />

<!-- Custom styling -->
<ASignInButton color="success" variant="outline" />
```

**Why?** Follows Nuxt UI patterns. Developers expect standard prop interfaces.

### Smart Defaults with Flexibility

Every component works out-of-the-box but can be customized:

```vue
<!-- Zero config - just works -->
<ASignInButton />

<!-- Fully customized -->
<ASignInButton :leading-icon="undefined" size="lg" variant="outline">
  Get Started
</ASignInButton>
```

### Boolean Feature Controls

Control features using standard boolean props that align with Vue ecosystem conventions:

```vue
<!-- ✅ Standard Vue pattern -->
<ASignUpForm :social="false" :secondary="false" />

<!-- Works with reactive data -->
<ASignUpForm :social="!isSimpleMode" :secondary="showSignInButton" />

<!-- Clear for complex props -->
<ASignUpForm :legal="['termsOfService']" />
<ASignUpForm :legal="false" />
```

**Why?** Boolean props are:

- **Familiar**: Consistent with Nuxt UI and Vue ecosystem patterns
- **Reactive**: Easy to bind to component state (`isLoading`, `showAdvanced`, etc.)
- **Unambiguous**: No conflicts between different prop types
- **Predictable**: Standard boolean logic (`true` = show, `false` = hide)

This follows established conventions while maintaining the principle:

> Make the common case easy, and the edge cases possible. Full-featured by default, easy to customize when needed.

## Integration Patterns

### Nuxt UI First

We extend Nuxt UI rather than creating custom components:

```vue
<!-- We use UButton for our SignInButton -->
<UButton :to="auth.getAuthUrl('sign-in')">
  {{ t('auth.signIn') }}
</UButton>
```

**Why?** Consistent design system. Developers already know Nuxt UI patterns.

### App Config Integration

Icons and theme settings merge with existing app config:

```typescript [app.config.ts]
export default defineAppConfig({
  ui: {
    icons: {
      authSignIn: "i-custom-login", // Override our defaults
    },
  },
});
```

**Why?** Single source of truth for design tokens. No duplicate config.

### Standard i18n Integration

Uses the standard `@nuxtjs/i18n` module with `auth` namespace:

```typescript [i18n.config.ts]
export default {
  messages: {
    en: {
      auth: {
        signIn: "Sign In",
        signUp: "Sign Up",
      },
    },
  },
};
```

**Why?** Standard approach. See [Internationalization](/docs/configuration/internationalization) for full setup details.

### Global Configuration with Local Control

Configure once globally, override locally when needed:

See [Configuration](/docs/configuration) for complete setup details.

```vue
<!-- Uses global config -->
<ASignUpForm />

<!-- Override for specific use case -->
<ASignUpForm :legal="['termsOfService']" />

<!-- Disable completely -->
<ASignUpForm :legal="false" />
```

**Why?**

- **DRY**: Set URLs once, use everywhere
- **Flexible**: Override per component when needed
- **Progressive**: Start simple, customize as needed
- **Maintainable**: Update legal URLs in one place

## Development Guidelines

When extending or customizing components, follow these patterns:

### Use Composables

Leverage our composables for consistency:

```vue
<script setup>
const auth = useAuthUI(); // Auth state & navigation
const appConfig = useAppConfig(); // Theme & icons
</script>
```

## Naming Conventions

### Avoid Redundant Prefixes

Component names should be concise and avoid redundancy with the module prefix:

```vue
<!-- Good: Clean, no redundancy -->
<AContainer />
<AUserMenu />

<!-- Not `AAuthContainer` or `AAuthUserMenu` -- The `A` prefix already indicates auth context -->
```

**Why?** The configurable prefix (default: `A`) already provides namespace context. Additional "Auth" in names creates unnecessary verbosity.

## Error Handling & Notifications

### Error Display Hierarchy

Show errors where the user's attention is focused:

```vue
<!-- Form errors: Show inline, near the action -->
<UForm @error="onError">
  <UFormField name="email" />
  <UFormField name="password" />
  
  <!-- General form errors here, not in toasts -->
  <UAlert v-if="error" color="error" class="mt-4">
    {{ error }}
  </UAlert>
  
  <UButton type="submit">Sign In</UButton>
</UForm>
```

### Toast Usage Guidelines

Use toasts only for:

- **Success notifications** - Action completed, navigating away
- **Background errors** - Errors outside the current focus area
- **Async updates** - Changes from other parts of the app

```typescript
// Good: Success with navigation
const handleSuccess = () => {
  toast.add({
    title: 'Signed in successfully!',
  })

  navigateTo('/dashboard')
}

// ❌ Bad, should show inline
validation error const handleError = (error) => {
  toast.add({
    title: 'Signing in failed',
  })
}
```

**Why?** Users should see errors where they're working. Toasts can be missed or dismissed accidentally. Inline errors provide immediate, contextual feedback.

### Simple Error State Management

Form error methods use simple, predictable behavior:

```typescript
// setError() replaces current error (not adds to array)
signInForm.value?.setError("Invalid credentials");

// setError(null) clears the error
signInForm.value?.setError(null);
```

**Why?** Simple, predictable API. One error shown at a time prevents overwhelming the user.

## Minimalism & Progressive Disclosure

### Minimal Sign-up by Design

Our sign-up form is intentionally minimal, collecting only email and password:

```vue
<!-- Sign-up asks only for essentials -->
<ASignUpForm />
<!-- Just email + password + confirmation -->
```

**Why?** Based on UX research and industry best practices:

- **Higher conversion**: Every additional field reduces sign-up conversion by ~7-10%
- **Lower friction**: Get users in the door first
- **Progressive profiling**: Collect additional data when contextually relevant
- **Modern pattern**: Used by GitHub, Linear, Vercel, and other successful apps

### Clear Scope Boundaries

We explicitly do NOT handle:

- **Post-auth onboarding**: Apps decide when/how to collect additional profile data
- **Custom fields**: Apps build their own forms for domain-specific data
- **Profile completion tracking**: Business logic that varies per application

```vue
<!-- We provide auth UI -->
<!-- Minimal sign-up -->
<ASignUpForm />

<!-- You handle app-specific needs -->
<!-- Your custom onboarding -->
<MyOnboardingWizard />
```

**Why?**

- **Focus**: We do auth UI exceptionally well, nothing more
- **Flexibility**: Every app has unique onboarding needs
- **Maintainability**: Avoiding scope creep keeps the module lean

### Extension Through Composition

Instead of configuration for everything, use composition:

```vue
<!-- Need more fields? Build your own form using our composables -->
<script setup>
const { signUp } = useAuthUI();

const handleCustomSignUp = async (formData) => {
  // Collect what you need
  await collectCustomData(formData);

  // Use our auth logic
  await signUp(formData.email, formData.password);
};
</script>
```

**Why?** Configuration systems always hit limits. Composition is infinitely flexible.

## Summary

These principles ensure consistency, maintainability, and a great developer experience:

1. **Minimal by default** - Sign-up with just email/password for higher conversion
2. **Clear scope boundaries** - Auth UI only, no business logic
3. **Boolean feature controls** - Use standard Vue patterns for consistency
4. **Global config, local control** - Set once, override when needed
5. **Ecosystem alignment** - Follow Vue/Nuxt UI conventions
6. **Nuxt UI integration** - Extend, don't replace existing patterns
7. **Composition over configuration** - For complex needs, use our composables
