---
title: Design Principles
description: Core design decisions behind Lightstack Nuxt Auth UI
navigation.order: 3
---

Understanding the design philosophy behind our auth UI will help you use them effectively and extend them when needed.

## Component Architecture

### Conditional Rendering

Components show/hide based on authentication state:

```vue
<template>
  <!-- Only renders when unauthenticated -->
  <ASignInButton />

  <!-- Only renders when authenticated -->
  <AUserMenu />
</template>
```

**Why?** Clean, predictable behavior. No need for manual state management.

## Configuration Philosophy

### Configurable Prefixes

Both routes and components use configurable prefixes:

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  authUi: {
    routes: {
      signIn: '/auth/sign-in'
    }
    componentPrefix: "A",    // Components: ASignInButton
  },
});
```

**Why?** Prevents naming conflicts and allows customization per project needs.

### Override-Friendly Props

Components accept standard Nuxt UI props that can be overridden:

```vue
<!-- Default with icon -->
<ASignInButton />

<!-- Custom icon -->
<ASignInButton leading-icon="i-heroicons-user" />

<!-- No icon -->
<ASignInButton :leading-icon="undefined" />

<!-- Custom styling -->
<ASignInButton color="success" variant="outline" />
```

**Why?** Follows Nuxt UI patterns. Developers expect standard prop interfaces.

### Smart Defaults with Flexibility

Every component works out-of-the-box but can be customized:

```vue
<!-- Zero config - just works -->
<ASignInButton />

<!-- Fully customized -->
<ASignInButton :leading-icon="undefined" size="lg" variant="outline">
  Get Started
</ASignInButton>
```

## Integration Patterns

### Nuxt UI First

We extend Nuxt UI rather than creating custom components:

```vue
<!-- We use UButton, not custom AuthButton -->
<UButton :to="auth.getAuthUrl('sign-in')">
  {{ locale.t('signIn') }}
</UButton>
```

**Why?** Consistent design system. Developers already know Nuxt UI patterns.

### App Config Integration

Icons and theme settings merge with existing app config:

```typescript [app.config.ts]
export default defineAppConfig({
  ui: {
    icons: {
      authSignIn: "i-custom-login", // Override our defaults
      // ... your other icons
    },
  },
});
```

**Why?** Single source of truth for design tokens. No duplicate config.

### Optional i18n Integration

Works standalone or integrates with existing i18n setup:

```typescript [nuxt.config.ts]
// Works without i18n
authUi: {
  messages: {
    en: {
      signIn: "Login";
    }
  }
}

// Or with @nuxtjs/i18n
i18n: {
  messages: {
    en: {
      authUi: {
        signIn: "Login";
      }
    }
  }
}
```

**Why?** Doesn't force dependencies. Adapts to existing project setup.

## Development Guidelines

When extending or customizing components, follow these patterns:

### Use Composables

Leverage our composables for consistency:

```vue
<script setup>
const auth = useAuthUI(); // Auth state & navigation
const appConfig = useAppConfig(); // Theme & icons
</script>
```

### Follow Nuxt UI Patterns

When creating new components, use Nuxt UI as the foundation:

```vue
<!-- Good: Extends UButton -->
<UButton v-bind="$attrs" :to="url">
  <slot />
</UButton>

<!-- Avoid: Custom implementation -->
<button class="custom-btn" @click="navigate">
  <slot />
</button>
```

## Naming Conventions

### Avoid Redundant Prefixes

Component names should be concise and avoid redundancy with the module prefix:

```vue
<!-- Good: Clean, no redundancy -->
<AContainer />
<AUserMenu />

<!-- Not `AAuthContainer` or `AAuthUserMenu` -- The `A` prefix already indicates auth context -->
```

**Why?** The configurable prefix (default: `A`) already provides namespace context. Additional "Auth" in names creates unnecessary verbosity.

## Error Handling & Notifications

### Error Display Hierarchy

Show errors where the user's attention is focused:

```vue
<!-- Form errors: Show inline, near the action -->
<UForm @error="onError">
  <UFormField name="email" />
  <UFormField name="password" />
  
  <!-- General form errors here, not in toasts -->
  <UAlert v-if="error" color="error" class="mt-4">
    {{ error }}
  </UAlert>
  
  <UButton type="submit">Sign In</UButton>
</UForm>
```

### Toast Usage Guidelines

Use toasts only for:

- **Success notifications** - Action completed, navigating away
- **Background errors** - Errors outside the current focus area
- **Async updates** - Changes from other parts of the app

```typescript
// Good: Success with navigation
const handleSuccess = () => {
  toast.add({
    title: 'Signed in successfully!',
  })

  navigateTo('/dashboard')
}

// Bad: Form
validation error const handleError = (error) => {
  toast.add({
    title: 'Signing in failed',
  }) // ‚ùå Should show inline
}
```

**Why?** Users should see errors where they're working. Toasts can be missed or dismissed accidentally. Inline errors provide immediate, contextual feedback.

These principles ensure consistency, maintainability, and a great developer experience.
